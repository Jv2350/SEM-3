//1. Producer and consumer problem

public class ProducerConsumer {
    public static void main(String[] args) {
        // Create a shared Shop object
        Shop c = new Shop();

        // Create and start a Producer thread
        Producer p1 = new Producer(c, 1);
        p1.start();

        // Create and start a Consumer thread
        Consumer c1 = new Consumer(c, 1);
        c1.start();
    }
}

// Shop class represents a shared resource where producers put materials and consumers get materials
class Shop {
    private int materials;
    private boolean available = false;

    // Consumer method to get materials from the shop
    public synchronized int get() {
        while (!available) {
            try {
                // If materials are not available, the consumer waits until materials are put by the producer
                wait();
            } catch (InterruptedException ie) {
                // Handle interrupted exception if it occurs during waiting
                ie.printStackTrace();
            }
        }
        // When materials are available, the consumer takes them and notifies waiting threads (producers)
        available = false;
        notifyAll();
        return materials;
    }

    // Producer method to put materials into the shop
    public synchronized void put(int value) {
        while (available) {
            try {
                // If materials are available, the producer waits until they are consumed by the consumer
                wait();
            } catch (InterruptedException ie) {
                // Handle interrupted exception if it occurs during waiting
                ie.printStackTrace();
            }
        }
        // When materials are consumed, the producer puts new materials and notifies waiting threads (consumers)
        materials = value;
        available = true;
        notifyAll();
    }
}

// Consumer class represents a thread that consumes materials from the shop
class Consumer extends Thread {
    private Shop shop;
    private int number;

    public Consumer(Shop c, int number) {
        shop = c;
        this.number = number;
    }

    public void run() {
        int value = 0;
        for (int i = 0; i < 10; i++) {
            // The consumer gets materials from the shop and prints the output
            value = shop.get();
            System.out.println("Consumer consumed " + this.number + " value and got: " + value);
        }
    }
}

// Producer class represents a thread that produces and puts materials into the shop
class Producer extends Thread {
    private Shop shop;
    private int number;

    public Producer(Shop c, int number) {
        shop = c;
        this.number = number;
    }

    public void run() {
        for (int i = 0; i < 10; i++) {
            // The producer puts materials into the shop and prints the output
            shop.put(i);
            System.out.println("Producer produced " + this.number + " value and put: " + i);
            try {
                // The producer sleeps for a random time (up to 100 milliseconds) to simulate production time
                sleep((int) (Math.random() * 100));
            } catch (InterruptedException ie) {
                // Handle interrupted exception if it occurs during sleeping
                ie.printStackTrace();
            }
        }
    }
}

//2. Determine submission of non- negative number using multithreading
import java.util.Scanner;

public class Summation {

    public static void main(String[] args) {
        try {
            int n;
            Scanner s = new Scanner(System.in);
            System.out.print("Enter the value: ");
            n = s.nextInt(); // Read the user input
            Job j1 = new Job(n); // Create a new Job object with the user input as the parameter
        } catch (Exception e) {
            // If any exception occurs during input or job creation, this block will execute
            System.out.println("Some process failed to complete...");
            System.out.println("Please contact the system admin...");
        }
    }
}


// Class representing a job that calculates the summation of numbers from 1 to a given input value
class Job implements Runnable {
    int a1; // Variable to store the input value
    Thread t; // Thread to run the job

    // Constructor to create a Job object and start a new thread for this job
    Job(int a) {
        a1 = a;
        t = new Thread(this);
        t.start(); // Start the thread and execute the run() method
    }

    // The run() method is called when the thread starts running
    public void run() {
        int b = 0; // Variable to store the summation result

        try {
            // Calculate the summation of numbers from 1 to the input value (a1)
            for (int i = 1; i <= a1; i++) {
                b = b + i;
                Thread.sleep(100); // Add a delay of 100 milliseconds to simulate some processing
            }
            // The 'try' block finishes here

            // Print the result inside the 'try' block
            System.out.println("The summation is: " + b);
            System.out.println("Job is over");
        } catch (InterruptedException e) {
            // If the thread is interrupted during the sleep, this block will execute
            System.out.println("The job has been interrupted...");
        }
    }
}

// Main class that takes user input and starts the job


//3. Write a multithread program that outputs prime number
    import java.util.Scanner;

    // Create a class named "Job" that implements the Runnable interface
    class Job implements Runnable {
        int a1;        // Declare an integer variable to store a number
        Thread t;      // Declare a Thread object for concurrent execution

        // Constructor to initialize the number and start a new thread
        Job(int a) {
            a1 = a;       // Assign the input number to the instance variable
            t = new Thread(this);  // Create a new thread that runs the "run" method of this class
            t.start();   // Start the thread's execution
        }

        // The "run" method is called when the thread starts executing
        public void run() {
            try {
                int i, k = 0;
                for (i = 2; i < a1; i++) {
                    Thread.sleep(100);  // Pause the thread for 100 milliseconds
                    if (a1 % i == 0) {
                        System.out.println("Number is not prime");
                        k = 1;         // Set "k" to 1 to indicate the number is not prime
                        break;         // Exit the loop since we found a factor
                    }
                }
                if (k == 0) {
                    System.out.println("Number is prime");  // If "k" is still 0, the number is prime
                }
                System.out.println("Job is over");  // This message is printed when the thread completes its task
            } catch (InterruptedException e) {
                System.out.println("The job has been interrupted"); // Handle interruptions gracefully
            }
        }
    }

    public class Prime {
        public static void main(String args[]) {
            try {
                int n;
                Scanner s = new Scanner(System.in);
                System.out.print("Enter the value: ");
                n = s.nextInt();  // Read an integer from the user
                Job ji = new Job(n);  // Create a Job object with the user-provided number
            } catch (Exception e) {
                System.out.println("Some process failed to complete...");
                System.out.println("Please contact the system admin...");
            }
        }
    }


//4. Write a multithread program that outputs fibonacci series
import java.io.*;
import java.util.Scanner;

class job implements Runnable{
    int a1;
    Thread t;
    job(int a){
        a1 = a;
        t = new Thread(this);
        t.start();
    }

    public void run(){
        int t1 = 0, t2 =1;
        try{
            int i;
            for (i=1;i<=a1;++i){
                Thread.sleep(100);
                System.out.print(t1+" ");
                int sum = t1 + t2;
                t1 = t2;
                t2 = sum;
            }
            System.out.println("\nJob is over!!");
        } catch(InterruptedException e){
            System.out.println("The job has beeen interrupted");
        }
    }
}

class fibonacci{
    public static void main(String[] args){
        try{
            int n;
            Scanner s = new Scanner(System.in);
            System.out.print("Enter the value: ");
            n = s.nextInt();
            job j1 = new job(n);
        } catch(Exception e){
            System.out.println("Some process failed to complete");
            System.out.println("Please contact system admin");
        }
    }
}

//5.Write program to contradict the barber and customer using java  synchronization (sleeping barber problem)
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class SleepingBarber {
    public static void main(String args[]) {
        // Create an instance of the barbershop.
        Bshop shop = new Bshop();

        // Create a barber and a customer generator, passing the shop instance.
        Barber barber = new Barber(shop);
        CustomerGenerator cg = new CustomerGenerator(shop);

        // Create threads for the barber and customer generator.
        Thread thbarber = new Thread(barber);
        Thread thcg = new Thread(cg);

        // Start the threads.
        thcg.start();
        thbarber.start();
    }
}

class Barber implements Runnable {
    Bshop shop;

    public Barber(Bshop shop) {
        this.shop = shop;
    }

    public void run() {
        System.out.println("Barber started..");
        while (true) {
            // The barber keeps cutting hair as long as there are customers in the shop.
            shop.cutHair();
        }
    }
}

class Customer implements Runnable {
    String name;
    Date inTime;

    Bshop shop;

    public Customer(Bshop shop) {
        this.shop = shop;
    }

    public String getName() {
        return name;
    }

    public Date getIntime() {
        return inTime;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setIntime(Date inTime) {
        this.inTime = inTime;
    }

    public void run() {
        // When a customer runs, they go for a hair cut.
        goForHairCut();
    }

    // This method adds the customer to the barbershop.
    private synchronized void goForHairCut() {
        shop.add(this);
    }
}

class CustomerGenerator implements Runnable {
    Bshop shop;
    private static int customerCount = 0;

    public CustomerGenerator(Bshop shop) {
        this.shop = shop;
    }

    public void run() {
        while (true) {
            // Generate a new customer and set their arrival time.
            Customer customer = new Customer(shop);
            customer.setIntime(new Date());

            // Generate a unique customer name.
            String customerName = "Customer " + customerCount++;
            customer.setName(customerName);

            Thread thcustomer = new Thread(customer);

            // Start the customer thread.
            thcustomer.start();

            try {
                // Wait for a random time (up to 10 seconds) before generating the next customer.
                TimeUnit.SECONDS.sleep((long) (Math.random() * 10));
            } catch (InterruptedException iex) {
                iex.printStackTrace();
            }
        }
    }
}

class Bshop {
    int nchair;
    List<Customer> listCustomer;

    public Bshop() {
        // Initialize the barbershop with 2 chairs and an empty customer list.
        nchair = 2;
        listCustomer = new LinkedList<Customer>();
    }

    public void cutHair() {
        Customer customer;

        // The barber waits for the lock on the customer list.
        System.out.println("Barber is waiting for lock");
        synchronized (listCustomer) {
            // If the customer list is empty, the barber waits for a customer.
            while (listCustomer.isEmpty()) {
                System.out.println("Barber is waiting for customer");
                try {
                    listCustomer.wait();
                } catch (InterruptedException iex) {
                    iex.printStackTrace();
                }
            }

            // When a customer is found in the queue, remove them from the list.
            System.out.println("Barber found a customer in the queue");
            customer = listCustomer.remove(0);
        }

        long duration = 0;
        try {
            // The barber simulates cutting hair for a random duration (up to 10 seconds).
            System.out.println("Cutting hair of customer: " + customer.getName());
            duration = (long) (Math.random() * 10);
            TimeUnit.SECONDS.sleep(duration);
        } catch (InterruptedException iex) {
            iex.printStackTrace();
        }

        // After cutting hair, the barber informs that the customer's hair is cut.
        System.out.println("Completed cutting hair of customer: " + customer.getName() + " in " + duration + " seconds.");
    }

    public void add(Customer customer) {
        // When a customer enters the shop, their arrival time is displayed.
        System.out.println("Customer: " + customer.getName() + " entering the shop at " + customer.getIntime());

        synchronized (listCustomer) {
            // If there are no available chairs, the customer leaves the shop.
            if (listCustomer.size() == nchair) {
                System.out.println("No chair available for customer " + customer.getName());
                System.out.println("Customer " + customer.getName() + " exits..");
                return;
            }

            // If there is an available chair, the customer takes it and is added to the list.
            listCustomer.add(customer);
            System.out.println("Customer: " + customer.getName() + " got the chair.");

            // If this is the first customer in the list, notify the barber that a customer is waiting.
            if (listCustomer.size() == 1) {
                listCustomer.notify();
            }
        }
    }
}

//6. Implement FCFS scheduling algorithm in java
import java.util.*;

public class FCFS {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter the number of processes: ");
        int n = sc.nextInt();
        int pid[] = new int[n];
        int ar[] = new int[n];
        int bt[] = new int[n];
        int ct[] = new int[n];
        int ta[] = new int[n];
        int wt[] = new int[n];
        int temp;
        float avgwt = 0, avgta = 0;

        // Input process arrival time and burst time
        for (int i = 0; i < n; i++) {
            System.out.print("Enter process " + (i + 1) + " arrival time: ");
            ar[i] = sc.nextInt();
            System.out.print("Enter process " + (i + 1) + " burst time: ");
            bt[i] = sc.nextInt();
            pid[i] = i + 1; // Assign process IDs
        }

        // Sort processes based on their arrival times using bubble sort
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n - (i + 1); j++) {
                if (ar[j] > ar[j + 1]) {
                    // Swap arrival time, burst time, and process IDs
                    temp = ar[j];
                    ar[j] = ar[j + 1];
                    ar[j + 1] = temp;
                    temp = bt[j];
                    bt[j] = bt[j + 1];
                    bt[j + 1] = temp;
                    temp = pid[j];
                    pid[j] = pid[j + 1];
                    pid[j + 1] = temp;
                }
            }
        }

        // Calculate completion time, turnaround time, and waiting time for each process
        for (int i = 0; i < n; i++) {
            if (i == 0) {
                ct[i] = ar[i] + bt[i];
            } else {
                if (ar[i] > ct[i - 1]) {
                    ct[i] = ar[i] + bt[i];
                } else
                    ct[i] = ct[i - 1] + bt[i];
            }
            ta[i] = ct[i] - ar[i];
            wt[i] = ta[i] - bt[i];
            avgwt += wt[i];
            avgta += ta[i];
        }

        // Display the process details
        System.out.println("\nPID  Arrival  Burst  Complete  Turnaround  Waiting");
        for (int i = 0; i < n; i++) {
            System.out.println(pid[i] + "\t" + ar[i] + "\t" + bt[i] + "\t" + ct[i] + "\t" + ta[i] + "\t\t" + wt[i]);
        }

        sc.close();
        
        // Calculate and display average waiting time and average turnaround time
        System.out.println("\nAverage Waiting Time: " + (avgwt / n));
        System.out.println("Average Turnaround Time: " + (avgta / n));
    }
}

//7. Implement shortest job first scheduling algorithm in java
import java.util.*;

public class SJF {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter no of processes: ");
        int n = sc.nextInt();
        int pid[] = new int[n];
        int at[] = new int[n];
        int bt[] = new int[n];
        int ta[] = new int[n];
        int wt[] = new int[n];
        int ct[] = new int[n];
        int f[] = new int[n];

        int st = 0, tot = 0;
        float avgwt = 0, avgta = 0;

        for (int i = 0; i < n; i++) {
            System.out.print("Enter process " + (i + 1) + " Arrival time: ");
            at[i] = sc.nextInt();
            System.out.print("Enter process " + (i + 1) + " Burst time: ");
            bt[i] = sc.nextInt();
            pid[i] = i + 1;
            f[i] = 0;
        }

        boolean a = true;
        while (true) {
            int c = n, min = 999;
            if (tot == n)
                break;

            for (int i = 0; i < n; i++) {
                if (at[i] <= st && f[i] == 0 && bt[i] < min) {
                    min = bt[i];
                    c = i;
                }
            }
            if (c == n)
                st++;
            else {
                ct[c] = st + bt[c];
                st += bt[c];
                ta[c] = ct[c] - at[c];
                wt[c] = ta[c] - bt[c];
                f[c] = 1;
                tot++;
            }
        }
        
        System.out.println("\nPID\tArrival\tBurst\tComplete\tTurnaround\tWaiting");
        for (int i = 0; i < n; i++) {
            avgwt += wt[i];
            avgta += ta[i];
            System.out.println(pid[i] + "\t" + at[i] + "\t" + bt[i] + "\t" + ct[i] + "\t\t" + ta[i] + "\t\t" + wt[i]);
        }
        System.out.println("\nAverage turnaround time is " + (float) (avgta / n));
        System.out.println("Average waiting time is " + (float) (avgwt / n));
        sc.close();
    }
}

//8. Implement round robin scheduling algorithm in java
import java.util.Arrays;

public class RR {
    static void findWaitingTime(int processes[], int n, int bt[], int wt[], int quantum) {
        int rem_bt[] = new int[n];
        // Initialize remaining burst times as the original burst times
        for (int i = 0; i < n; i++)
            rem_bt[i] = bt[i];
        
        int t = 0; // Current time
        
        while (true) {
            boolean done = true; // To check if all processes are done
            
            // Traverse all processes
            for (int i = 0; i < n; i++) {
                if (rem_bt[i] > 0) {
                    done = false;
                    
                    // If remaining burst time is more than the quantum, decrease it by quantum
                    if (rem_bt[i] > quantum) {
                        t += quantum;
                        rem_bt[i] -= quantum;
                    } 
                    // If remaining burst time is less than or equal to the quantum, finish the process
                    else {
                        t = t + rem_bt[i];
                        wt[i] = t - bt[i];
                        rem_bt[i] = 0;
                    }
                }
            }
            
            // If all processes are done, exit the loop
            if (done == true)
                break;
        }
    }

    static void findTurnAroundTime(int processes[], int n, int bt[], int wt[], int tat[]) {
        for (int i = 0; i < n; i++)
            tat[i] = bt[i] + wt[i];
    }

    static void findavgTime(int processes[], int n, int bt[], int quantum) {
        int wt[] = new int[n], tat[] = new int[n];
        int total_wt = 0, total_tat = 0;

        // Calculate waiting time for all processes
        findWaitingTime(processes, n, bt, wt, quantum);

        // Calculate turnaround time for all processes
        findTurnAroundTime(processes, n, bt, wt, tat);

        // Print the table
        System.out.println("Processes\tBurst Time\tWaiting Time\tTurnaround Time");
        for (int i = 0; i < n; i++) {
            total_wt += wt[i];
            total_tat += tat[i];
            System.out.println(processes[i] + "\t\t" + bt[i] + "\t\t" + wt[i] + "\t\t" + tat[i]);
        }

        // Calculate and print average waiting time and average turnaround time
        float avg_wt = (float) total_wt / n;
        float avg_tat = (float) total_tat / n;
        System.out.println("\nAverage Waiting Time = " + avg_wt);
        System.out.println("Average Turnaround Time = " + avg_tat);
    }

    public static void main(String[] args) {
        int processes[] = {1, 2, 3};
        int n = processes.length;
        int burst_time[] = {10, 5, 8};
        int quantum = 2;

        findavgTime(processes, n, burst_time, quantum);
    }
}


//9. Implement fifo page in java
import java.util.Scanner;

public class FIFO {
    public static void main(String[] args) {
        int f, p, num = 0, pageHit = 0;
        int pages[];
        int frame[];
        boolean flag = true;

        try (Scanner input = new Scanner(System.in)) {
            System.out.print("Enter number of frames: ");
            f = input.nextInt();

            System.out.print("Enter number of pages: ");
            p = input.nextInt();

            frame = new int[f];
            pages = new int[p];

            for (int i = 0; i < f; i++)
                frame[i] = -1;

            System.out.print("Enter page number: ");
            for (int i = 0; i < p; i++)
                pages[i] = input.nextInt();
        }
        for (int i = 0; i < p; i++) {
            flag = true;
            int page = pages[i];
            for (int j = 0; j < f; j++) {
                if (frame[j] == page) {
                    flag = false;
                    pageHit++;
                    break;
                }
            }
            if (num == f)
                num = 0;
            if (flag) {
                frame[num] = page;
                num++;
            }
            System.out.print("Frame: ");
            for (int k = 0; k < f; k++)
                System.out.print(frame[k] + " ");
            System.out.println();
        }
        System.out.print("No. of pages hit: " + pageHit);
    }
}

//10. Implement LrU page replacement in java
import java.util.*;

class LRU {
    Scanner sc = new Scanner(System.in);
    int[] frame, page, present;
    int size, pages, pf = 0, flag = 0, flag1 = 0;

    LRU(int size, int pages) {
        this.size = size;
        this.pages = pages;
        frame = new int[size];
        present = new int[size];
        page = new int[pages];
    }

    void get() {
        System.out.println("Enter pages");
        for (int i = 0; i < pages; i++)
            page[i] = sc.nextInt();
        for (int i = 0; i < size; i++)
            frame[i] = -1;
    }

    int check(int x) {
        flag = -1;
        for (int i = 0; i < size; i++)
            if (frame[i] == x) {
                flag = i;
                break;
            }
        return flag;
    }

    int replace(int x) {
        int i;
        for (i = 0; i < size; i++)
            present[i] = 0;
        flag1 = 0;
        for (i = x - 1; i >= 0; i--) {
            if (check(page[i]) >= 0) {
                flag1++;
                present[check(page[i])] = 1;
            }
            if (flag1 == (size - 1))
                break;
        }
        for (i = 0; i < size; i++)
            if (present[i] == 0) {
                flag1 = i;
                break;
            }
        return i;
    }

    void lru() {
        for (int i = 0; i < pages; i++) {
            if (i < size) {
                frame[i] = page[i];
                pf++;
                for (int j = 0; j < size; j++)
                    System.out.print(frame[j] + "    ");
                System.out.println();
            } else {
                if (check(page[i]) == -1) {
                    int r = replace(i);
                    frame[r] = page[i];
                    pf++;
                    for (int j = 0; j < size; j++)
                        System.out.print(frame[j] + "    ");
                    System.out.println();
                } else {
                    for (int j = 0; j < size; j++)
                        System.out.print(frame[j] + "    ");
                    System.out.println();
                }
            }
        }
        System.out.println("PAGE FAULT: " + pf);
    }
}

class LRU1 {
    public static void main(String arg[]) {
        Scanner s = new Scanner(System.in);
        System.out.print("Enter frame size:");
        int n = s.nextInt();
        System.out.print("Enter no of pages:");
        int p = s.nextInt();
        LRU obj = new LRU(n, p);
        obj.get();
        obj.lru();
    }
}

//11. reader writer problem
class Database {
	private int readers;

	public Database() {
		this.readers = 0;
	}

	public void read(int number) {
		synchronized (this) {
			this.readers++;
			System.out.println("Reader " + " starts reading.");
		}
		final int DELAY = 5000;
		try {
			Thread.sleep((int) (Math.random() * DELAY));
		} catch (InterruptedException e) {
		}
		synchronized (this) {
			System.out.println("Reader " + number + "stops reading.");
			this.readers--;
			if (this.readers == 0) {
				this.notifyAll();
			}
		}
	}

	public synchronized void write(int number) {
		while (this.readers != 0) {
			try {
				this.wait();
			} catch (InterruptedException e) {
			}
		}
		System.out.println("Writer " + number + "starts waiting.");
		final int DELAY = 5000;
		try {
			Thread.sleep((int) (Math.random() * DELAY));
		} catch (InterruptedException e) {
		}
		System.out.println("Writer " + number + "stops writing.");
		this.notifyAll();
	}
}

class Reader extends Thread {
	private static int readers = 0;
	private int number;
	private Database database;

	/**
	 * Creates a Reader for the specified database.
	 * 
	 * @param database database from which to be read.
	 */
	public Reader(Database database) {
		this.database = database;
		this.number = Reader.readers++;
	}

	public void run() {
		while (true) {
			final int DELAY = 5000;
			try {
				Thread.sleep((int) (Math.random() * DELAY));
			} catch (InterruptedException e) {
			}
			this.database.read(this.number);
		}
	}
}

class Writer extends Thread {
	private static int writers = 0;

	private int number;
	private Database database;

	/**
	 * Creates a Writer for the specified database.
	 * 
	 * @param database database to which to write.
	 */
	public Writer(Database database) {
		this.database = database;
		this.number = Writer.writers++;
	}

	/**
	 * writes.
	 */
	public void run() {
		while (true) {
			final int DELAY = 5000;
			try {
				Thread.sleep((int) (Math.random() * DELAY));
			} catch (InterruptedException e) {
			}
			this.database.write(this.number);
		}
	}
}

public class Simulator {
	/**
	 * Creates the specified number of readers and writers and starts them.
	 * 
	 * @param args[0] The number of readers.
	 * @param args[1] The number of writers.
	 */
	public static void main(String[] args) {
		if (args.length < 2) {
			System.out.println("Usage: java Simulator <number of readers> <number of writers>");
		} else {
			final int READER = Integer.parseInt(args[0]);
			final int WRITER = Integer.parseInt(args[1]);
			Database database = new Database();
			for (int i = 0; i < READER; i++) {
				new Reader(database).start();
			}
			for (int i = 0; i < WRITER; i++) {
				new Writer(database).start();
			}
		}
	}
}

//13. Demonstrate the concept of synchronized access to shared resource
class room {

    public synchronized void takesLecture(String name) throws InterruptedException {
        System.out.println(name + " enters...");
        Thread.sleep(250);
        System.out.println(name + " starts lecture...");
        Thread.sleep(500);
        System.out.println(name + " exits...");
        Thread.sleep(250);
    }
}

class lecturer implements Runnable {
    String name;
    room r;
    Thread t;

    lecturer(String n, room r) {
        name = n;
        t = new Thread(this, n);
        this.r = r;
    }

    public void start() {
        t.start();
    }

    public void run() {
        try {
            r.takesLecture(name);
        } catch (InterruptedException e) {
            System.out.println(name + " operation interrupted...");
        }
    }
}

class os {

    public static void main(String args[]) {
        room r = new room();
        lecturer kamlakar = new lecturer("Kamlakar Sir", r);
        lecturer madhavi = new lecturer("Madhavi Madam", r);
        lecturer prajisha = new lecturer("Prajisha Madam", r);
        kamlakar.start();
        madhavi.start();
        prajisha.start();
    }
}